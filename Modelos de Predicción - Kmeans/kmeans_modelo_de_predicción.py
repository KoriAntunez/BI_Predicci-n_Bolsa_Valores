# -*- coding: utf-8 -*-
"""Kmeans - Modelo de Predicción

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Etlk2Tb3XZL8mx9kbco1pLtstAjR-QUf

Modelo de Predicción Kmenans
"""

#%% Carga de librerías.
import pandas as pd
from sklearn import preprocessing 
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

#%% Carga del dataframe.
df = pd.read_csv("google.csv")
df.head()

#%% Se eliminan filas que tengan valor NaN.
 df = df.dropna()
 df = df.reset_index(drop=True)

#%% Eliminamos columna de fecha que no usaremos en el algoritmo.
dates = df['Date'] # Guardamos la columna Date.
df = df.drop('Date', 1) # Borramos la columna del dataframe.

#del(df['Open'])
del(df['High'])
del(df['Low'])
del(df['Adj Close'])

#%% Se normalizan los datos con MinMax()
min_max_scaler = preprocessing.MinMaxScaler() 
df_escalado = min_max_scaler.fit_transform(df)
df_escalado = pd.DataFrame(df_escalado) # Hay que convertir a DF el resultado.
df_escalado = df_escalado.rename(columns = {0: 'Close', 1: 'Volume'})
df_escalado.head()

#%% Se normalizan los datos con MinMax()
min_max_scaler = preprocessing.MinMaxScaler() 
df_escalado = min_max_scaler.fit_transform(df)
df_escalado = pd.DataFrame(df_escalado) # Hay que convertir a DF el resultado.
df_escalado = df_escalado.rename(columns = {0: 'Close', 1: 'Volume'})

#%% Representación gráfica de los datos.
x = df_escalado['Close'].values
y = df_escalado['Volume'].values
plt.xlabel('Close price')
plt.ylabel('Volume')
plt.title('Google vs. VOLUME')
plt.plot(x,y,'o',markersize=1)

#%% Curva elbow para determinar valor óptimo de k.
nc = range(1, 30) # El número de iteraciones que queremos hacer.
kmeans = [KMeans(n_clusters=i) for i in nc]
score = [kmeans[i].fit(df_escalado).score(df_escalado) for i in range(len(kmeans))]
score
plt.xlabel('Número de clústeres (k)')
plt.ylabel('Suma de los errores cuadráticos')
plt.plot(nc,score)

#%% Aplicación de k-means con k = 5.
kmeans = KMeans(n_clusters=5).fit(df_escalado)
centroids = kmeans.cluster_centers_
print(centroids)

#%% Etiquetamos nuestro dataframe.
labels = kmeans.predict(df_escalado)
df['label'] = labels

#%% Añadimos la columna de fecha
df.insert(0, 'Date', dates)

#%% Plot k-means clustering.
colores=['red','green','blue','yellow','fuchsia']
asignar=[]
for row in labels:
     asignar.append(colores[row])
plt.scatter(x, y, c=asignar, s=1)
plt.scatter(centroids[:, 0], centroids[:, 1], marker='*', c='black', s=20) # Marco centroides.
plt.xlabel('Close price')
plt.ylabel('Volume')
plt.title('Google stocks k-means clustering')
plt.show()