# -*- coding: utf-8 -*-
"""SVM&RF_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g646lFGs3Oob1-N8mdmuU7RAC1NZhRF0
"""

!pip install plotly

# Machine learning
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
  
# For data manipulation
import pandas as pd
import numpy as np
  
# To plot
import matplotlib.pyplot as plt
plt.style.use('seaborn-darkgrid')
  
# To ignore warnings
import warnings
warnings.filterwarnings("ignore")

data = pd.read_csv('GOOG.csv')
data

data.info()

data.index = pd.to_datetime(data['Date'])
data = data.drop(['Date'], axis='columns')
data

"""La X consiste en variables como 'Abrir – Cerrar' y 'Alto – Bajo'. Estos pueden entenderse como indicadores en base a los cuales el algoritmo predecirá la tendencia del mañana."""

# Create predictor variables
data['Open-Close'] = data.Open - data.Close
data['High-Low'] = data.High - data.Low
data

# Store all predictor variables in a variable X
X = data[['Open-Close', 'High-Low']]
X.head()

"""Y es un conjunto de datos objetivo que almacena la señal comercial correcta que el algoritmo de aprendizaje automático intentará predecir.
Si el precio de mañana es mayor que el precio de hoy, entonces compraremos la acción en particular, de lo contrario no tendremos posición en el. Almacenaremos +1 para una señal de compra y 0 para una posición de no en y
"""

y = np.where(data['Close'].shift(-1) > data['Close'], 1, 0)
y

"""Dividiremos los datos en conjuntos de datos de entrenamiento y prueba."""

split_percentage = 0.8
split = int(split_percentage*len(data))
  
# Train data set
X_train = X[:split]
y_train = y[:split]
  
# Test data set
X_test = X[split:]
y_test = y[split:]

"""## MODELO DE CLÁSIFICADOR DE VECTORES DE SOPORTE (SVC)

Clasificador de vectores de soporte (SVC)

Creación del modelo clasificador utilizando el método fit() en el conjunto de datos de entrenamiento

Usaremos la función SVC() de la biblioteca sklearn.svm.SVC para crear nuestro modelo clasificador usando el método fit() en el conjunto de datos de entrenamiento.
"""

from sklearn import svm
cls = svm.SVC(probability=True).fit(X_train, y_train)

def predict_model(model,X_test):
  y_pred = model.predict(X_test)
  return y_pred

"""## EVALUACIÓN DEL MODELO SVC"""

# REPORTE DE MÉTRICAS
from sklearn.metrics import classification_report
print(classification_report(y_test, predict_model(cls,X_test)))

# MATRIZ DE CONFUSIÓN
def plot_confusion_matrix(model,X_test,y_test):
  from sklearn.metrics import confusion_matrix
  import plotly.express as px
  predict = predict_model(model,X_test)
  confusion_matrix = confusion_matrix(y_test, predict).astype(int)
  fig = px.imshow(confusion_matrix, text_auto=True)
  fig.show()

plot_confusion_matrix(cls,X_test,y_test)

def plot_bar_metricas_classification(model,X_test):
  from sklearn import metrics
  y_pred = predict_model(model,X_test)
  accuracy = metrics.accuracy_score(y_test, y_pred)
  precision = metrics.precision_score(y_test, y_pred)
  sensivity = metrics.recall_score(y_test, y_pred)
  f1_score = metrics.f1_score(y_test, y_pred)

  # DATAFRAME DE MÉTRICAS
  metrics = {
    'metrics' : ['Exactitud', 'Precisión', 'Sensibilidad','F1-score'],
    'valor': [accuracy, precision, sensivity,f1_score]
  }
  metrics = pd.DataFrame(metrics)
  import plotly.express as px
  fig = px.bar(metrics, x="metrics", y="valor", color="metrics",text_auto=True,title="Métricas del modelo")
  fig.show()

# GRÁFICA DE LAS PRINCIPALES MÉTRICAS
plot_bar_metricas_classification(cls,X_test)

def plot_roc_curve(model,X_test,y_test):
  from sklearn.metrics import roc_curve, auc
  # svm
  predictions = model.predict_proba(X_test)
  predictions = predictions[:, 1]
  model_fpr, model_tpr, threshold = roc_curve(y_test, predictions)
  auc_model = auc(model_fpr, model_tpr)

  plt.figure(figsize=(5, 5), dpi=100)

  plt.plot(model_fpr, model_tpr, linestyle='-', label='Modelo (auc = %0.3f)' % auc_model)

  plt.xlabel('False Positive Rate')
  plt.ylabel('True Positive Rate')

  plt.legend()

  plt.show()

plot_roc_curve(cls,X_test,y_test)

"""## ESTRATEGIA DE LA IMPLEMENTACIÓN"""

data['Predicted_Signal'] = cls.predict(X)
data['Predicted_Signal']

conditionlist = [
    (data['Predicted_Signal'] == 1) ,
    (data['Predicted_Signal'] == 0)]
choicelist = ['Comprar','Vender']
data['Decision'] = np.select(conditionlist, choicelist)
data

"""Predeciremos la señal (comprar o vender) usando la función cls.predict().

Calcular devoluciones diarias
"""

# Calculate daily returns
data['Return'] = data.Close.pct_change()
data

"""Calcular los rendimientos de la estrategia"""

data['Strategy_Return'] = data.Return*data.Predicted_Signal.shift(1)
data

"""Calcular rendimientos acumulativos"""

data['Cum_Ret'] = data['Return'].cumsum()
data

"""Calcular los rendimientos acumulativos de la estrategia"""

data['Cum_Strategy'] = data['Strategy_Return'].cumsum()
data

"""### Retornos de la estrategia de trama vs rendimientos originales"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
  
plt.plot(data['Cum_Ret'],color='red')
plt.plot(data['Cum_Strategy'],color='blue')

"""## MODELO DE CLASIFICACIÓN RANDOM FOREST"""

from sklearn.ensemble import RandomForestClassifier
rfc = RandomForestClassifier(n_estimators=100,random_state=101,criterion='gini')
rfc.fit(X_train, y_train)

rfc_pred = rfc.predict(X_test)

"""### PREDICCIÓN DEL MODELO RANDOM FOREST"""

# PREDICCIÓN DEL MODELO
predict_model(rfc,X_test)
predict_model_rfc = predict_model(rfc,X_test)

# REPORTE DE MÉTRICAS
plot_confusion_matrix(rfc,X_test,y_test)

plot_bar_metricas_classification(rfc,X_test)

plot_roc_curve(rfc,X_test,y_test)

"""## COMPARACIÓN DE MODELOS"""

def plot_roc_curve_models(model,model2,X_test,y_test):
  
  from sklearn.metrics import roc_curve, auc
  # model
  predictions = model.predict_proba(X_test)
  predictions = predictions[:, 1]
  model_fpr, model_tpr, threshold = roc_curve(y_test, predictions)
  auc_model = auc(model_fpr, model_tpr)

  # model
  predictions2 = model2.predict_proba(X_test)
  predictions2 = predictions2[:, 1]
  model2_fpr, model2_tpr, threshold = roc_curve(y_test, predictions2)
  auc_model2 = auc(model2_fpr, model2_tpr)

  plt.figure(figsize=(5, 5), dpi=100)

  plt.plot(model_fpr, model_tpr, linestyle='-', label='Modelo svc (auc = %0.3f)' % auc_model)
  plt.plot(model2_fpr, model2_tpr, marker='.', label='Modelo rf (auc = %0.3f)' % auc_model2)

  plt.xlabel('False Positive Rate')
  plt.ylabel('True Positive Rate')

  plt.legend()

  plt.show()

plot_roc_curve_models(cls,rfc,X_test,y_test)

"""## GRÁFICO DE VELAS"""

import plotly.graph_objects as go
candlestick = go.Candlestick(
                            x=data.index,
                            open=data['Open'],
                            high=data['High'],
                            low=data['Low'],
                            close=data['Close']
                            )

fig = go.Figure(data=[candlestick])

fig.update_layout(
    width=800, height=600,
    title="GOOGLE",
    yaxis_title='Price Stock'
)

fig.show()